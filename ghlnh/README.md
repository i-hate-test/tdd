
## Chapter02 TDD 시작

### TDD 흐름

테스트를 통과한 뒤에는 개선할 코드가 있으면 리팩토링한다. 리팩토링을 수행한 뒤에는 다시 테스트를 실행해서 기존 기능이 망가지지 않았는지 확인한다. 이 과정을 반복하면서 점진적으로 기능을 완성해 나가는 것, 이것이 전형적인 TDD의 흐름이다. 

### 테스트가 개발을 주도

테스트 코드를 만들면 다음 개발 범위가 정해진다. 테스트 코드가 추가되면서 검증하는 범위가 넓어질 수록 구현도 점저 완성되어 간다. 이렇게 테스트가 개발을 주도해 나간다.

### 지속적인 코드 정리

구현 완료→리팩토링 진행

리팩토링할 대상이 눈에 들어오면 리팩토링 진행하면서 코드 정리

당장 리팩토링할 대상이나 어떻게 리팩토링 할지 생각 나지 않으면 다음 테스트 진행

테스트 코드 자체도 리팩토링 대상에 포함

잘 동작하는 코드를 수정하는 것은 심리적으로 불안감을 주기 때문에 코드 수정을 꺼리게 만든다. 하지만 해당 기능이 온전하게 동작한다는 것을 검증해주는 테스트가 있으면 코드 수정에 대한 심리적 불안감을 줄여준다. 리팩토링을 통한 개선을 원활하게 할수 있게 도와준다. 

➡️TDD는 개발과정에서 지속적으로 코드 정리를 하므로 코드 품질이 급격하게 나빠지지 않게 막아주는 효과가 있다. 이는 향후 유지보수 비용을 낮추는데 기여한다. 

## Chapter03 테스트 코드 작성순서

### 초반에 복잡한 테스트부터 시작하면 안되는 이유

한번에 많은 코드를 만들다보면 나도 모르게 버그를 만들고 나중에 버그를 잡기 위해 많은 시간을 허비하게 된다. 코드 작성시간이 길어질 수록 집중력이 낮아진다.

### 구현하기 쉬운 테스트 부터 시작하기

한번에 구현하는 시간이 짧아지면 디버깅할 때 유리하다. 작성한 코드가 많지 않고 작성시간도 짧으면 머릿속에 코드에 대한 내용이 생생하게 남아 있기 때문에 디버깅할 때 문제 원인을 빠르게 찾을 수 있다.

### 예외 상황을 먼저 테스트해야 하는 이유

예외 상황을 처리하지 않아 NPE발생→프로세스가 죽을 수도 있음. 사소한 버그가 서비스 중단을 일으킬 수 있으므로 예외 상황을 찾고 테스트 하면 이런 문제가 발생할 가능성을 사전에 낮출 수 있다.

### 완급조절

1️⃣정해진 값을 리턴→2️⃣값 비교를 이용해서 정해진 값을 리턴→3️⃣다양한 테스트를 추가하면서 구현을 일반화

몇 차례 상수를 사용해서 테스트를 통과시키고 뒤에 구현을 일반화하는 과정이 처음에는 지루하게 느껴질 수 있으나 이런 연습과정은 나중에 만들어야 할 코드가 잘 떠오르지 않을 때 점진적으로 구현을 진행 할 수 있는 밑거름이 된다. 

### 지속적인 리팩토링

테스트 / 코드에서 상수→변수 이거나 변수 이름을 변경 등의 작은 리팩토링은 바로 실행

메소드 추출과 같이 메서드의 구조에 영향을 주는 큰 리팩토링은 큰 틀에서 구현하면서 눈에 전체적은 구현 흐름이 들어 온뒤에 실행

### 다음테스트를 추가하지 전에 리팩토링

파라미터 개수는 적을 수록 코드 가족성과 유지보수에 유리하므로 메서드의 파라미터 개수가 세 개 이상이면 객체로 바꿔 한 개로 바꿔 줄이는 것을 고려해야 한다. 

### 테스트할 목록 정리하기

TDD시작할 때 테스트할 목록을 미리 정리하면 좋다. 테스트할 내용을 정리했다면 이 중에 어떤 테스트가 구현이 쉬울지 상상해 보고 어떤 테스트가 예외적인지 상상해본다. 시간을 조금 들여서 구현의 난이도나 구조를 검토하면 다음 테스트를 선택할 때 도움이 된다. 

테스트 과정에서 새로운 테스트 사례를 발견하면 그 사례를 목록에 추가해서 놓치지 않도록 해야한다. 처음부터 모든 사례를 정리하면 시간도 오래 걸릴 뿐더러 쉽지도 않다. 개발을 진행하다 보면 생각지도 못한 테스트 사례를 발견하기 마련이다. 이때 새로 발견한 내용을 테스트 목록에 추가해서 놓치지 말아야 한다.

지라 또는 트렐로 같은 시스템 사용하면 해당 테스트 사례를 하위 작업으로 등록해서 테스트 통과 여부를 추적할 수 있다.

[협업툴 플로우(Flow), 노션(Notion), 지라(Jira), 트렐로(Trello) 비교](https://m.blog.naver.com/skomj/222477979988)

하나의 테스트 코드를 만들고 이를 통과시키고 리팩토링하고 다시 다음 테스트 코드를 만들고 통과시키고 리팩토링하는 과정은 비교적 짧은 리듬을 반복한다. 다루는 범위가 작고 개발 주기도 짧으므로 개발 집중력도 높아진다.

TDD는 리팩토링을 통해 지속해서 코드를 정리하는데 개발을 진행하다보면 변경 범위가 매우 큰 리팩토링 거리를 발견할 때도 있다. 범위가 큰 리팩토링은 시간이 오래 걸리므로 TDD흐름을 깨기 쉽다. 이때는 리팩토링을 진행하지 말고 테스트를 통과시키는 데 집중한다. 대신 범위가 큰 리팩토링은 다음 할 일 목록에 추가해서 놓치지 않고 진행 할 수 있게 한다. 

## Chapter 04 TDD 기능·명세·설계

기능 실행 결과에는 변경도 포함된다. 예를 들어 회원 가입 기능은 실행 결과로 DB에 회원정보를 추가한다. DB에 데이터를 추가하는 것은 값을 리턴하는 거소가 달리 시스템의 상태를 변경한다. 이런 변경은 리턴 값으로는 결과를 알 수 없기 때문에 테스트 대상을 실행 한 뒤에는 변경 대상에 접근해서 결과를 확인해야 한다. 


설계는 기능 명세로부터 시작한다. 스토리보드를 포함한 다양한 형태의 요구사항 문서를 이용해서 기능명세를 구체화한다. 기능 명세를 구체화하는 동안 입력과 결과를 도출하고 이렇게 도출한 기능 명세를 코드에 반영한다. 기능 명세의 입력과 결과를 코드에 반영하는 과정에서 기능의 이름, 파라미터, 리턴 타입 등이 결정된다. 이는 곧 기능에 대한 설계과정과 연결된다. 

### 설계과정을 지원하는 TDD

테스트 코드를 만들기 위한 2가지

- 테스트할 기능을 실행
- 실행 결과를 검증

테스트 코드에서는 기능을 실행 할 수 있어야 하므로 테스트에서 실행 할 수 있는 객체나 함수가 존재해야한다. 실행할 객체가 존재하려면 객체를 생성할 때 사용할 클래스가 필요하고 실행할 메서드도 필요하다. 다시 말해 테스트 대상이 되는 클래스와 메서드의 이름을 결정해야 한다. 또한, 메서드를 실행할 때 사용할 인자의 타입과 개수를 결정해야 한다. 

테스트 코드 작성하는 과정에서 결정되는 사항들 

- 클래스 이름
- 메서드 이름
- 메서드 파라미터
- 실행 결과

위 4가지 결정하는 과정은 곧 설계 과정이다. 타입의 이름을 정의하고, 타입이 제공할 기능을 결정하는 것은 기본적으로 설계 행위이다. 

🔔시간이 다소 걸리더라도 알맞은 이름을 찾아야 하며 이름을 고민할 시간을 아까워하지 말자

### 필요한 만큼 설계하기

TDD로 개발을 진행하면 현시점에서 테스트를 통과시키는 데 필요한 만큼의 코드만 만들게 된다. 물론 모든 코드에 대해 테스트를 먼저 작성할 수 는 없겠지만 TDD로 개발하는 코드 비율이 높아질 수 록 지금 시점에서 필요한 설계만 코드에 반영할 가능성이 커진다. 유연한 설계는 필요한 시점에 추가한다. 이를 통해 설계가 복잡해지는 것을 방지 할 수 있다. 

⚠️TDD로 개발할 때 필요한 만큼 설계를 한다고 해서 사전에 설계 활동을 생략하는 것은 아니다. 요구사항을 분석하는 과정에서 당연히 설계를 진행 한다.

모호한 상황을 만나면 이를 구체적인 예로 바꾸어 테스트 코드에 반영한다. 즉, 테스트 코드는 예를 이용한 구체적인 명세가 된다. 구체적인 예는 개발자가 요구사항을 더 잘 이해 할 수 있게 만든다. 서비스 만료일도 요구사항만 보면 어떻게 구현해야 할지 애매한 상황이 많다. 구체적인 예는 이런 모호함을 없애 주어 개발자가 올바르게 동작하는 기능을 만들 수 있게 한다 .

특정 상황에서 코드가 어떻게 동작하는지 이해하고 싶다면 해당 상황을 검증하는 테스트를 실행하고 이해가 필요한 코드를 추적하면 된다. 디버거를 이용해서 추적할 수 있고 콘솔에 출력되는 로그를 보면서 이해를 높일 수 있다. 

## Chapter 05 JUnit5 기초

### 주요 단언메서드

| 메서드 | 설명 |
| --- | --- |
| assertEquals(expected, actual) | 실제값(actual)이 기대하는 값(expected)과 같은지 검사 |
| assertNotEquals(unexpected, actual) | 실제값(actual)이 특정값(unexpected)과 같은지 검사 |
| assertSame(Object expected, Object actual) | 두 객체가 동일한 객체인지 검사한다 |
| assertNotSame(Object unexpected, Object actual) | 두 객체가 동일하지 않은 객체인지 검사한다 |
| assertTrue(boolean condition) | 값이 true인지 검사한다 |
| assertFalse(boolean condition) | 값이 false인지 검사한다 |
| assertNull(Object actual) | 값이 null인지 검사한다 |
| asssertNotNull(Object actual) | 값이 null이 아닌지 검사한다 |
| fail() | 테스트를 실패 처리한다 |
| assertThrows(Class<T> expectedType, Excutable excutalbe) | excutable을 실행한 결과로 지정한 타입의 익셉션이 발생하는지 검사한다 |
| assertDoesNotThrow(Excutable excutable) | excutable을 실행한 결과로 익셉션이 발생하지 않는니 검사한다 |

🔔주요타입 별로 `assertEquals()`메서드가 존재한다(int,Long, Object 등등…) `assertEquals()`메서드를 사용할 때 주의할 점은 첫번째 인자가 기대하는 값이고 두번재가 검사하려는 값이다.

## Chapter 06 테스트 코드 구성

- 상황찾기
    
    노련한 개발자는 어떤 상황이 실행 결과에 영향을 줄 수 있는지 찾기 위해 노력한다. 결과에 영향을 줄 수 있는 상황을 고려하지 않고 작성한 코드는 버그를 포함할 가능성이 크기 때문이다. 다양한 예외 상황을 찾아내고 이를 코드에 반영해야 기능이 비정상적으로 동작하는 것을 막을수 있다. 결과에 영향을 줄 수 있는 모든 상황을 완벽하게 찾기 힘들 수도 있지만 가능한 많은 예외 상황을 찾기 위해 노력해야 한다. 그렇게 함으로써 개발한 소프트웨어의 품질을 높일 수 있다.
    

### 테스트 코드의 구성 요소: 상황, 실행, 결과 확인

기능은 상황에 따라 결과가 달라진다. 테스트 코드는 기능을 실행하고 그 결과를 확인하므로 상황, 실행, 결과 확인의 세 가지 요소로 테스트를 구성할 수 있다. 어떤 상황이 주어지고, 그 상황에서 기능을 실행하고, 실행한 결과를 확인하는 세가지가 테스트 코드의 기본 골격을 이루게 된다. 

### 외부 상태가 테스트 결과에 영향을 주지 않게 하기

테스트 코드는 한 번만 실행하고 끝나지 않는다. TDD를 진행하는 동안에도 계속 실행하고 개발이 끝난 이후에도 반복적으로 테스트를 실행해서 문제가 없는지 검증한다. 그렇기 때문에 테스트는 언제 실행해도 항상 정상적으로 동작하는 것이 중요하다. 간헐적으로 실패하거나 다른 테스트 다음에 실행해야 성공하면 테스트 결과를 믿을 수 없게 된다. 이렇게 되면 테스트가 실패해도 무감각해지고 나아가 테스트를 만들지 않게 된다. 

외부상황에 따라 테스트의 성공 여부가 바뀌지 않으려면 테스트 실행 전에 외부를 원하는 상태로 만들거나 테스트 실행 후에 외부 상태를 원래대로 되돌려 놓아야 한다. 

### 외부 상태와 테스트 어려움

테스트 대상이 아닌 외부 요인은 테스트 코드에서 다루기 힘든 존재이다. 외부 상황은 테스트 코드에서 마음대로 제어할 수 없는 경우가 있다. 테스트 코드에서 생성한 외부 결과를 마음대로 초기화하기 힘들 때도 있다. 이렇게 테스트 대상의 상황과 결과에 외부 요인이 관여할 경우, 대역을 사용하면 테스트 작성이 쉬워진다. 대역은 테스트 대상이 의존하는 대상의 실제 구현을 대신하는 구현인데 이 대역을 통해서 외부 상황이나 결과를 대체할 수 있다.

## Chapter07 대역

### 대역의 종류

| 대역 종류 | 설명 |
| --- | --- |
| 스텁(Stub) | 구현을 단순한 것으로 대체한다. 테스트에 맞게 단순히 원하는 동작을 수행한다. |
| 가짜(Fake) | 제품에는 적합하지 않지만, 실제 동작하는 구현을 제공한다. |
| 스파이(Spy) | 호출된 내역을 기록한다. 기록한 내용은 테스트 결과를 검증할 때 사용한다. 스텁이기도 하다. |
| 모의(Mock) | 기대한 대로 상호작용하는지 행위를 검증한다. 기대한 대로 동작하지 않으면 예외를 발생할 수 있다. 모의 객체는 스텁이자 스파이도 된다. |
- 구현하기 전에 설계해보기
    
    구현하기 전에 모든 기능을 설계하는 것은 불가능하다. 왜냐면 개발을 진행하는 동안에도 요구사항이 계속해서 바꾸기 때문
    
    그럼에도 불구하고 단위 기능을 구현하기 앞서 어떤 구성 요소가 필요할지 고민하는 것은 의존 대상을 도출할 때 도움이 된다. 
    
    물론 사전에 설계한 그대로 만들어지는 것은 아님. 구현하다 보면 설계한 것과 다른 의존대상이 출현하기도 필요할 거라 생각했던 의존 대상이 사라지기도 함
    

### 상황과 결과 확인을 위한 협업대상(의존) 도출과 대역 사용

제어하기 힘든 외부 상황이 존재하면 다음과 같은 방법으로 의존을 도출하고 이를 대역으로 대신할 수 있다.

- 제어하기 힘든 외부 상황을 별도 타입으로 분리
- 테스트 코드는 별도로 분맇나 타입의 대역을 생성
- 생성한 대역을 테스트 대상의 생성자등을 이용해서 전달
- 대역을 이용해서 상황 구성

### 대역과 개발 속도

대역을 사용하면 실제 구현이 없어도 다양한 상황에 대해 테스트할 수 있다. 또 실제 구현이 없어도 실행 결과를 확인 할 수 있다. 

즉, 대역은 의존하는 대상을 구현하지 않아도 테스트 대상을 완성할 수 있게 만들어주며 이는 대기 시간을 줄여주어 개발 속도를 올리는 데 도움이 된다. 

### 모의 객체를 과하게 사용하지 않기

모의 객체를 이용하면 대역 클래스를 만들지 않아도 된까 처음엔 편할 수 있다. 하지만 결과 값을 확인하는 수단으로 모의 객체를 사용하기 시작하면 결과 검증 코드가 길어지고 복잡해진다.

특히 하나의 테스트를 위해 여러 모의 객체를 사용하기 시작하면 결과 검증 코드의 복잡도는 배로 증가한다. 게다가 모의 객체는 기본적으로 메서드 호출 여부를 검증하는 수단이기 때문에 테스트 대상과 모의 객체간의 상호작용이 조금만 바뀌어도 테스트가 깨지 쉽다.

➡️모의 객체의 메서드 호출 여부를 결과 검증 수단으로 사용하는 것은 주의!

특히 DAO나 리포지토리 같이 저장소에 대한 대역은 모의 객체를 사용하는 것보다 메모리를 이용한 가짜 구현을 사용하는 것이 테스트 코드 관리에 유리함.

귀찮아도 가짜 대역을 구현하면 모의 객체를 사용할때보다 테스트 코드가 간결해지고 관리가 쉬움

## Chapter 09 테스트 범위와 종류

### 테스트 범위 간 차이

- 테스트 실행시 준비 사항
    - 통합 테스트: DB나 캐시 서버와 같은 연동대상을 구성
    - 기능 테스트: 웹서버를 구동하거나 모바일 앱을 폰을 설치해야할 수 있음
    - 단위 테스트: 테스트 코드
- 테스트 실행 속도 (단위>통합>기능)
    - 통합 테스트: 테스트 실행 속도를 느리게 만드는 요인 多(DB연결, 소켓 통신, 스프링 컨테이너 초기화 등등…)
    - 기능 테스트: 통합 테스트+브라우저나 앱을 구동하고 화면의 흐름에 따라 알맞은 상호작용 필요
    - 단위 테스트: 테스트 대상이 의존하는 기능을 대역으로 처리하면 되어 빠름
- 결과 확인
    
    ➡️통합 테스트, 기능 테스트로는 상황을 준비하거나 결과 확인이 어렵거나 불가능 할 때가 있음(특히 외부 시스템과 연동 하는 경우)👉단위 테스트와 대역을 조합하여 상황을 만들고 결과 확인해야 함
    

TDD를 하는지 여부와 상관없이 테스트 코드를 작성하는 개발자는 단위 테스트와 통합 테스트를 섞어서 작성한다. 통합 테스트를 실행하려면 준비해야 할 것이 많고 단위 테스트에 비해 실행 시간도 길지만, 그래도 통합 테스트는 필요하다. 

기능 테스트나 통합 테스트에서 모든 예외 상황을 테스트하면 단위 테스트는 줄어듦→각 테스트가 다루는 내용이 중복되기 때문

but, 단위테스트 속도가 통합 테스트 속도 보다 빠르기 때문에 가능하면 단위 테스트에서 다양한 상황을 다루고, 통합 테스트나 기능 테스트는 주요 상황에 초점을 맞춰야 한다. 

## Chapter 10 테스트 코드와 유지보수

지속적으로 코드를 통합하고 출시 가능한 상태로 만들고 배포하려면 새로 추가한 코드가 기존 기능을 망가뜨리지 않는지 확인할 수 있어야 하며 이런 이유로 자동화 테스트는 CI/CD의 필수 요건 중 하나이다. TDD를 하는 과정에서 작성한 테스트 코드는 CI/CD에서 자동화 테스트로 사용되어 버그가 배포되는 것을 막아주고 이는 소프트웨어 품질이 저하되는 것을 방지한다

깨지는 테스트를 방지하는 상황이 길어지게 되면 발생 할 문제

- 실패한 테스트가 새로 발생해도 무감각 해짐→테스트 실패 여부에 상관없이 빌드하고 배포하기 시작
- 빌드를 통과시키기 위해 실패한 테스트를 주석 처리하고 실패한 테스트는 고치지 않음

위와 같은 문제는 회귀 테스트가 검증하는 범위가 줄어듦➡️버그 발생 시, 놓치기 쉬움👉소프트웨어 품질 하락

*회귀테스트: 코드를 변경했을 때 기존 기능이 올바르게 동작하는지 확인하는 테스트*

이러한 악순환이 발생하지 않으려면 테스트 코드 자체의 유지보수성이 좋아야 한다. 테스트 코드를 유지보수하기 좋아야 지속적으로 테스트를 작성하게 되고 결과적으로 소프트웨어의 품질이 떨어지는 것도 막을 수 있다.

깨진 테스트가 발견되면 즉시 수정해서 테스트 실패가 확산 되는 것을 방지해야 한다. 

### 두개 이상을 검증하지 않기

두개 이상을 검증하는 테스트는 잘못된 것은 아니지만 한 테스트에서 검증하는 내용이 두 개 이상이면 테스트 결과를 확인 할 때 집중도가 떨어진다. 테스트에 검증 내용이 두 개 이상이면 첫번째 검증이 성공해야 두번째 검증의 성공여부를 확인 할 수 있고 테스트에 실패했을 때, 두 가지 검증 대상 중 무엇이 실패했는지 확인해야 된다. 

👉각 검증 대상을 별도로 분리해서 테스트의 집중도를 높임

물론 테스트 메서드가 반드시 한 가지만 검증해야 하는 것은 아니지만, 검증 대상이 명확하게 구분된다면 테스트 메서드도 구분하는 것이 유지보수에 유리하다.

### 정확하게 일치하는 값으로 모의 객체 설정하지 않기

모의 객체는 가능한 범용적인 값을 사용해서 기술해야 한다. 한정된 값에 일치하도록 모의 객체를 사용하면 약간의 코드 수정만으로도 테스트는 실패하게 된다. 이 경우 테스트 코드의 일부 값을 수정하면 모의 객체 관련 코드도 함께 수정하는 번거로움이 있다.

ex)테스트의 의도를 해치지 않는 범위에서 ‘pw’와 같은 특정한 값보다는 Mockito.anyString()과 같은 범용적인 값을 사용

### 과도하게 구현 검증하지 않기

내부 구현을 검증하는 것이 나쁜 것은 아니지만 구현을 조금만 변경해도 테스트가 깨질 가능성이 커진다. 내부 구현은 언제든지 바뀔 수 있기 때문에 테그트 코드는 내부 구현보다 실행 결과를 검증해야 한다. 

- 기능이 정상적으로 동작하는지 확인 할 수단이 구현 검증밖에 없다면 모의 객체를 사용해서 테스트 코드를 작성해야 하지만 일단 테스트 코드를 작성한 뒤에는 점진적으로 코드를 리팩토링해서 구현이 아닌 결과를 검증할 수 있도록 시도해야 한다. 그렇게 함으로써 향후에 사소한 구현 변경으로 인해 테스트가 깨지는 것을 방지할 수 있고 또한 코드의 테스트 가능성도 높일 수 있다.

### 셋업을 이용해서 중복된 상황을 설정하지 않기

셋업 메서드를 이용해서 여러 메서드에 동일한 상황을 적용하는 것이 처음에는 편리하지만, 시간이 지나면 테스트 코드를 이해하고 유지 보수하는데 오히려 방해 요소가 된다. 테스트 메서드는 자체적으로 검증하는 내용을 완전히 기술하고 있어야 테스트 코드를 유지보수하는 노력을 줄일 수 있다.

### 통합 테스트에서 데이터 공유 주의하기

통합 테스트 코드를 만들 때는 다음의 두 가지로 초기화 데이터를 나눠서 생각해야한다.

- 모든 테스트가 같은 값을 사용하는 데이터 ex)코드값 데이터
- 테스트 메서드에서만 필요한 데이터 ex)중복 ID검사를 위한 회원 데이터

모든 테스트가 동일한 코드값 데이터를 사용해도 문제가 없으며 오히려 서로 다른 코드값 데이터를 사용하면 문제가 발생할 수 있다. 이렇게 모든 테스트가 다른 값을 사용하면 안되는 데이터는 동일한 데이터를 공유해도 된다. 

### 통합 테스트의 상황 설정을 위한 보조 클래스 사용하기

검증을 위해 데이터를 조회하는 코드가 여러 테스트 메서드에 중복되어 있으면 유지보수에 좋지 않다. 이럴 때는 상황 설정과 동일하게 결과 검증을 위한 보조 클래스를 만들어 테스트 코드를 유지보수 하기 좋은 코드로 만들 수 있다.
